{
  "name": "3. Humanization Filter",
  "nodes": [
    {
      "parameters": {
        "content": "## 3. Humanization Filter - 사용 가이드\n\n### 목적\nAI 생성 콘텐츠를 더 자연스럽게 만들고 AI 탐지를 회피\n\n### 처리 단계\n1. **Typo Injector**: 페르소나별 오타 비율로 자연스러운 오타 삽입\n2. **Format Variator**: 문장 형식 변화 (소문자 시작, 줄임표 등)\n3. **Rhythm Breaker**: 문장 리듬 깨기 (짧은 문장, 대시 연결)\n4. **AI Detection Check**: AI 패턴 점수 측정\n\n### AI 탐지 점수\n- **A등급** (0-5점): 통과 → Workflow 4로\n- **B등급** (6-10점): 통과 → Workflow 4로  \n- **REWRITE** (11+점): 자동 수정 후 재검사\n\n### 감지되는 AI 패턴\n- delve, furthermore, moreover\n- \"it's important to note\"\n- \"I hope this helps\"\n- 다중 느낌표 (!!) 등\n\n### 웹훅 URL\n활성화 후 URL 복사 → Workflow 2의 `HUMANIZATION_WEBHOOK`에 설정\n\n### 입력 데이터\n← Workflow 2에서 초안 수신\n\n### 출력 데이터\n→ Workflow 4 (Scheduler)로 승인된 콘텐츠 전달\n\n### 커스터마이징\n- 오타 패턴 추가: 'Typo Injector' 노드\n- AI 탐지 패턴 추가: 'AI Detection Check' 노드",
        "height": 680,
        "width": 450
      },
      "id": "sticky-guide",
      "name": "Sticky Note",
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [-550, 50]
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "humanization-filter",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "webhook-trigger",
      "name": "Webhook Trigger",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [0, 300],
      "webhookId": "humanization-filter-webhook"
    },
    {
      "parameters": {
        "jsCode": "const draft = $input.first().json.body || $input.first().json;\n\n// Typo patterns with probabilities\nconst typoPatterns = [\n  { find: /\\bthe\\b/g, replace: 'teh', prob: 0.3 },\n  { find: /\\bjust\\b/g, replace: 'jsut', prob: 0.2 },\n  { find: /\\bwith\\b/g, replace: 'wiht', prob: 0.2 },\n  { find: /\\breally\\b/g, replace: 'realy', prob: 0.4 },\n  { find: /\\bdefinitely\\b/g, replace: 'definately', prob: 0.5 },\n  { find: /\\bbecause\\b/g, replace: 'becuase', prob: 0.3 },\n  { find: /\\btheir\\b/g, replace: 'thier', prob: 0.25 },\n  { find: /\\breceive\\b/g, replace: 'recieve', prob: 0.4 },\n  { find: /\\buntil\\b/g, replace: 'untill', prob: 0.35 },\n  { find: /\\bwhich\\b/g, replace: 'wich', prob: 0.2 }\n];\n\nlet content = draft.content;\nlet typosAdded = 0;\nconst persona = draft.persona;\nconst typoRate = persona.typoRate || 0.02;\n\n// Calculate max typos based on word count and persona's typo rate\nconst wordCount = content.split(/\\s+/).length;\nconst maxTypos = Math.max(1, Math.ceil(wordCount * typoRate));\n\n// Shuffle patterns for randomness\nconst shuffledPatterns = typoPatterns.sort(() => Math.random() - 0.5);\n\nfor (const pattern of shuffledPatterns) {\n  if (typosAdded >= maxTypos) break;\n  \n  const matches = content.match(pattern.find);\n  if (matches && Math.random() < pattern.prob * typoRate * 10) {\n    // Only replace the first occurrence\n    content = content.replace(pattern.find, (match, offset) => {\n      // Only replace if we haven't hit max and random chance\n      if (typosAdded < maxTypos && Math.random() < 0.5) {\n        typosAdded++;\n        return pattern.replace;\n      }\n      return match;\n    });\n  }\n}\n\nreturn {\n  json: {\n    ...draft,\n    content,\n    humanization: {\n      typosAdded,\n      stage: 'typos'\n    }\n  }\n};"
      },
      "id": "typo-injector",
      "name": "Typo Injector",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [220, 300]
    },
    {
      "parameters": {
        "jsCode": "const draft = $input.first().json;\nlet content = draft.content;\nconst persona = draft.persona;\n\n// Persona-specific format variations\nconst variations = [];\n\n// Sam (dev) often starts sentences lowercase\nif (persona.id === 'dev_sam' && Math.random() < 0.4) {\n  content = content.replace(/\\. ([A-Z])/g, (match, letter) => {\n    if (Math.random() < 0.3) {\n      variations.push('lowercase_start');\n      return `. ${letter.toLowerCase()}`;\n    }\n    return match;\n  });\n}\n\n// Add ellipses for personas who use them\nif (persona.phrases && persona.phrases.includes('...') && Math.random() < 0.3) {\n  const sentences = content.split('. ');\n  if (sentences.length > 2) {\n    const insertAt = Math.floor(Math.random() * (sentences.length - 1)) + 1;\n    sentences[insertAt - 1] = sentences[insertAt - 1] + '...';\n    content = sentences.join('. ');\n    variations.push('ellipsis_added');\n  }\n}\n\n// Occasional parenthetical aside\nif (Math.random() < 0.12 && content.includes(', ')) {\n  const asides = [\n    '(at least in my experience)',\n    '(ymmv)',\n    '(not always, but often)',\n    '(I could be wrong)',\n    '(still figuring this out tbh)'\n  ];\n  const aside = asides[Math.floor(Math.random() * asides.length)];\n  const parts = content.split(', ');\n  const insertAt = Math.floor(Math.random() * (parts.length - 1)) + 1;\n  parts[insertAt] = aside + ' ' + parts[insertAt];\n  content = parts.join(', ');\n  variations.push('aside_added');\n}\n\n// Occasional edit notation at the end\nif (Math.random() < 0.08) {\n  const edits = [\n    '\\n\\nedit: typo',\n    '\\n\\nedit: clarity',\n    '\\n\\neta: forgot to mention this applies mostly to early-stage'\n  ];\n  content += edits[Math.floor(Math.random() * edits.length)];\n  variations.push('edit_notation');\n}\n\n// Remove double spaces that might have been introduced\ncontent = content.replace(/  +/g, ' ');\n\nreturn {\n  json: {\n    ...draft,\n    content,\n    humanization: {\n      ...draft.humanization,\n      formatVariations: variations,\n      stage: 'format'\n    }\n  }\n};"
      },
      "id": "format-variator",
      "name": "Format Variator",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [440, 300]
    },
    {
      "parameters": {
        "jsCode": "const draft = $input.first().json;\nlet content = draft.content;\nconst changes = [];\n\n// Break up overly consistent rhythm\n// Occasionally add a very short sentence or fragment\nif (Math.random() < 0.15) {\n  const fragments = [\n    'Wild.',\n    'Seriously.',\n    'Go figure.',\n    'Right?',\n    'Same here.',\n    'Classic.',\n    'This.'\n  ];\n  \n  const sentences = content.split('. ');\n  if (sentences.length > 3) {\n    const fragment = fragments[Math.floor(Math.random() * fragments.length)];\n    const insertAt = Math.floor(Math.random() * (sentences.length - 2)) + 1;\n    sentences.splice(insertAt, 0, fragment);\n    content = sentences.join('. ');\n    changes.push('fragment_added');\n  }\n}\n\n// Occasionally combine sentences with dash instead of period\nif (Math.random() < 0.12) {\n  content = content.replace(/\\. ([A-Z][a-z])/, (match, start) => {\n    if (Math.random() < 0.5) {\n      changes.push('dash_connector');\n      return ` - ${start.toLowerCase()}`;\n    }\n    return match;\n  });\n}\n\n// Add occasional filler word\nif (Math.random() < 0.1) {\n  const fillers = ['honestly', 'basically', 'like', 'actually'];\n  const filler = fillers[Math.floor(Math.random() * fillers.length)];\n  \n  // Insert after first comma or period\n  if (content.includes(', ') || content.includes('. ')) {\n    const insertAfterComma = Math.random() < 0.5;\n    if (insertAfterComma && content.includes(', ')) {\n      content = content.replace(', ', `, ${filler}, `);\n      changes.push('filler_word');\n    }\n  }\n}\n\nreturn {\n  json: {\n    ...draft,\n    content,\n    humanization: {\n      ...draft.humanization,\n      rhythmChanges: changes,\n      stage: 'rhythm'\n    }\n  }\n};"
      },
      "id": "rhythm-breaker",
      "name": "Rhythm Breaker",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [660, 300]
    },
    {
      "parameters": {
        "jsCode": "const draft = $input.first().json;\nconst content = draft.content;\n\n// AI detection patterns with scores\nconst patterns = [\n  { regex: /\\bdelve\\b/i, score: 5, name: 'delve' },\n  { regex: /\\bfurthermore\\b/i, score: 3, name: 'furthermore' },\n  { regex: /\\bmoreover\\b/i, score: 3, name: 'moreover' },\n  { regex: /\\bin conclusion\\b/i, score: 4, name: 'in_conclusion' },\n  { regex: /\\bit'?s important to note\\b/i, score: 5, name: 'important_to_note' },\n  { regex: /\\bit'?s worth mentioning\\b/i, score: 5, name: 'worth_mentioning' },\n  { regex: /\\bnevertheless\\b/i, score: 3, name: 'nevertheless' },\n  { regex: /^However,/im, score: 2, name: 'however_start' },\n  { regex: /^Additionally,/im, score: 2, name: 'additionally_start' },\n  { regex: /!{2,}/g, score: 2, name: 'multiple_exclamation' },\n  { regex: /\\bI cannot help but\\b/i, score: 6, name: 'cannot_help' },\n  { regex: /\\bfeel free to\\b/i, score: 4, name: 'feel_free' },\n  { regex: /\\bI hope this helps\\b/i, score: 5, name: 'hope_this_helps' },\n  { regex: /\\bdon'?t hesitate to\\b/i, score: 4, name: 'dont_hesitate' },\n  { regex: /\\bat the end of the day\\b/i, score: 3, name: 'end_of_day' },\n  { regex: /\\bin today'?s world\\b/i, score: 4, name: 'todays_world' },\n  { regex: /\\bLet me explain\\b/i, score: 3, name: 'let_me_explain' },\n  { regex: /\\bTo be fair\\b/i, score: 1, name: 'to_be_fair' }, // Low score, used by humans too\n  { regex: /\\bI'?d be happy to\\b/i, score: 5, name: 'happy_to' },\n  { regex: /\\bAs an AI\\b/i, score: 10, name: 'as_an_ai' }, // Critical\n  { regex: /\\bAs a language model\\b/i, score: 10, name: 'language_model' } // Critical\n];\n\nlet totalScore = 0;\nconst issues = [];\n\nfor (const { regex, score, name } of patterns) {\n  if (regex.test(content)) {\n    totalScore += score;\n    issues.push({ pattern: name, score });\n  }\n}\n\n// Grade based on score\nlet grade;\nlet needsRewrite = false;\n\nif (totalScore <= 5) {\n  grade = 'A';\n} else if (totalScore <= 10) {\n  grade = 'B';\n} else {\n  grade = 'REWRITE';\n  needsRewrite = true;\n}\n\nreturn {\n  json: {\n    ...draft,\n    aiDetection: {\n      score: totalScore,\n      issues,\n      grade,\n      needsRewrite\n    },\n    humanization: {\n      ...draft.humanization,\n      stage: 'detection_check'\n    }\n  }\n};"
      },
      "id": "ai-detection-check",
      "name": "AI Detection Check",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [880, 300]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "quality-check",
              "leftValue": "={{ $json.aiDetection.needsRewrite }}",
              "rightValue": false,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "quality-gate",
      "name": "Quality Gate",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [1100, 300]
    },
    {
      "parameters": {
        "jsCode": "// Content passed quality check - prepare for scheduling\nconst draft = $input.first().json;\n\nreturn {\n  json: {\n    ...draft,\n    status: 'approved',\n    approvedAt: new Date().toISOString(),\n    humanization: {\n      ...draft.humanization,\n      stage: 'completed',\n      passed: true\n    }\n  }\n};"
      },
      "id": "prepare-approved",
      "name": "Prepare Approved",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1320, 200]
    },
    {
      "parameters": {
        "url": "={{ $vars.SCHEDULER_WEBHOOK }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify($json) }}",
        "options": {}
      },
      "id": "trigger-scheduler",
      "name": "Trigger Scheduler",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1540, 200]
    },
    {
      "parameters": {
        "jsCode": "// Content needs rewrite - clean up AI patterns and re-queue\nconst draft = $input.first().json;\nlet content = draft.content;\nconst issues = draft.aiDetection.issues;\n\n// Auto-fix some common issues\nconst replacements = {\n  'delve': ['explore', 'look at', 'dig into'],\n  'furthermore': ['also', 'plus', 'and'],\n  'moreover': ['also', 'and', 'plus'],\n  'nevertheless': ['still', 'but', 'though'],\n  'in conclusion': ['so', 'anyway', 'bottom line'],\n  'important to note': ['worth saying', 'fwiw'],\n  'worth mentioning': ['should say', 'gotta mention'],\n  'feel free to': ['go ahead and', 'you can'],\n  'hope this helps': ['hope that makes sense', 'lmk if questions'],\n  'dont hesitate': ['just', 'go ahead'],\n  'at the end of the day': ['ultimately', 'in the end'],\n  'todays world': ['these days', 'now'],\n  'let me explain': ['so basically', 'here\\'s the thing'],\n  'happy to': ['can', 'will']\n};\n\nfor (const issue of issues) {\n  const key = issue.pattern.replace(/_/g, ' ');\n  if (replacements[key]) {\n    const replacement = replacements[key][Math.floor(Math.random() * replacements[key].length)];\n    const regex = new RegExp(key.replace(/ /g, \"[' ]?\"), 'gi');\n    content = content.replace(regex, replacement);\n  }\n}\n\n// Remove multiple exclamation marks\ncontent = content.replace(/!{2,}/g, '!');\n\n// Fix sentences starting with However, or Additionally,\ncontent = content.replace(/^However,/gm, 'But');\ncontent = content.replace(/^Additionally,/gm, 'Also,');\n\nreturn {\n  json: {\n    ...draft,\n    content,\n    previousContent: draft.content,\n    status: 'rewritten',\n    rewriteCount: (draft.rewriteCount || 0) + 1,\n    humanization: {\n      ...draft.humanization,\n      stage: 'auto_rewrite',\n      autoFixes: issues.map(i => i.pattern)\n    }\n  }\n};"
      },
      "id": "auto-rewrite",
      "name": "Auto Rewrite",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1320, 400]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "retry-limit",
              "leftValue": "={{ $json.rewriteCount }}",
              "rightValue": 3,
              "operator": {
                "type": "number",
                "operation": "lt"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "retry-check",
      "name": "Retry Check",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [1540, 400]
    },
    {
      "parameters": {
        "jsCode": "// Re-run detection on auto-rewritten content\nconst draft = $input.first().json;\nconst content = draft.content;\n\nconst patterns = [\n  { regex: /\\bdelve\\b/i, score: 5 },\n  { regex: /\\bfurthermore\\b/i, score: 3 },\n  { regex: /\\bmoreover\\b/i, score: 3 },\n  { regex: /\\bin conclusion\\b/i, score: 4 },\n  { regex: /\\bit'?s important to note\\b/i, score: 5 },\n  { regex: /\\bit'?s worth mentioning\\b/i, score: 5 },\n  { regex: /\\bnevertheless\\b/i, score: 3 },\n  { regex: /^However,/im, score: 2 },\n  { regex: /!{2,}/g, score: 2 },\n  { regex: /\\bfeel free to\\b/i, score: 4 },\n  { regex: /\\bI hope this helps\\b/i, score: 5 }\n];\n\nlet totalScore = 0;\nfor (const { regex, score } of patterns) {\n  if (regex.test(content)) totalScore += score;\n}\n\nconst needsRewrite = totalScore > 10;\n\nif (needsRewrite) {\n  // Still needs work, loop back\n  return { json: { ...draft, aiDetection: { score: totalScore, needsRewrite: true } } };\n} else {\n  // Now passes, send to scheduler\n  return {\n    json: {\n      ...draft,\n      aiDetection: { score: totalScore, grade: totalScore <= 5 ? 'A' : 'B', needsRewrite: false },\n      status: 'approved',\n      approvedAt: new Date().toISOString()\n    }\n  };\n}"
      },
      "id": "recheck-detection",
      "name": "Recheck Detection",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1760, 300]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "passed-recheck",
              "leftValue": "={{ $json.status }}",
              "rightValue": "approved",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "recheck-gate",
      "name": "Recheck Gate",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [1980, 300]
    },
    {
      "parameters": {
        "url": "={{ $vars.SCHEDULER_WEBHOOK }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify($json) }}",
        "options": {}
      },
      "id": "trigger-scheduler-2",
      "name": "Trigger Scheduler 2",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [2200, 200]
    },
    {
      "parameters": {
        "jsCode": "// Failed after max retries - log for manual review\nconst draft = $input.first().json;\n\nreturn {\n  json: {\n    ...draft,\n    status: 'failed_humanization',\n    failureReason: 'Max rewrite attempts exceeded',\n    failedAt: new Date().toISOString()\n  }\n};"
      },
      "id": "log-failure",
      "name": "Log Failure",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1760, 500]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify({ success: true, status: $json.status, grade: $json.aiDetection?.grade }) }}",
        "options": {}
      },
      "id": "respond-webhook",
      "name": "Respond to Webhook",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [2420, 300]
    }
  ],
  "connections": {
    "Webhook Trigger": {
      "main": [
        [
          { "node": "Typo Injector", "type": "main", "index": 0 }
        ]
      ]
    },
    "Typo Injector": {
      "main": [
        [
          { "node": "Format Variator", "type": "main", "index": 0 }
        ]
      ]
    },
    "Format Variator": {
      "main": [
        [
          { "node": "Rhythm Breaker", "type": "main", "index": 0 }
        ]
      ]
    },
    "Rhythm Breaker": {
      "main": [
        [
          { "node": "AI Detection Check", "type": "main", "index": 0 }
        ]
      ]
    },
    "AI Detection Check": {
      "main": [
        [
          { "node": "Quality Gate", "type": "main", "index": 0 }
        ]
      ]
    },
    "Quality Gate": {
      "main": [
        [
          { "node": "Prepare Approved", "type": "main", "index": 0 }
        ],
        [
          { "node": "Auto Rewrite", "type": "main", "index": 0 }
        ]
      ]
    },
    "Prepare Approved": {
      "main": [
        [
          { "node": "Trigger Scheduler", "type": "main", "index": 0 }
        ]
      ]
    },
    "Trigger Scheduler": {
      "main": [
        [
          { "node": "Respond to Webhook", "type": "main", "index": 0 }
        ]
      ]
    },
    "Auto Rewrite": {
      "main": [
        [
          { "node": "Retry Check", "type": "main", "index": 0 }
        ]
      ]
    },
    "Retry Check": {
      "main": [
        [
          { "node": "Recheck Detection", "type": "main", "index": 0 }
        ],
        [
          { "node": "Log Failure", "type": "main", "index": 0 }
        ]
      ]
    },
    "Recheck Detection": {
      "main": [
        [
          { "node": "Recheck Gate", "type": "main", "index": 0 }
        ]
      ]
    },
    "Recheck Gate": {
      "main": [
        [
          { "node": "Trigger Scheduler 2", "type": "main", "index": 0 }
        ],
        [
          { "node": "Auto Rewrite", "type": "main", "index": 0 }
        ]
      ]
    },
    "Trigger Scheduler 2": {
      "main": [
        [
          { "node": "Respond to Webhook", "type": "main", "index": 0 }
        ]
      ]
    },
    "Log Failure": {
      "main": [
        [
          { "node": "Respond to Webhook", "type": "main", "index": 0 }
        ]
      ]
    }
  },
  "active": false,
  "versionId": "1",
  "settings": {
    "executionOrder": "v1"
  },
  "meta": {
    "instanceId": "community-automation"
  },
  "tags": [
    {
      "name": "community-automation"
    }
  ]
}
